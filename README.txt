Isaiah Gathala

For the ALU I just took what I have for the Lab 11 and expanded it to fit the new requirements. I added a few operations like shifting.

For the register file I also started with another lab and progressed. I added six registers and exapanded the two mux's to match. The difficult part was the two write ports. Since we only ever needed write B to be write A + 1, I had a bunch of muxes that had teh writeData1 at certain sopts and matchde that up with the writeSelect0 + 1. This way, if there was a writeEnable 1, the corresponding second register was already recieving the data. It was just whether the enable is on or not.

For the main cpu I had the rom that fed the instruction to an instruction decoder that split up the signals accordingly. All this information was then sent to something called the control that basically did all the work. First this contril had a decoder to decode the opcode into seperate signals. All these outputs were connected to tunnels to the corresponding command. Some of these outputs had muxes since two commands may have the same opcode but differetn subop codes so that further split them up. This was then send to a priority encoder that would create the correct ALUOp code. I had an or gate for all the commands that would use an immediate so that there was a signal that would tell the ALU port B to switch over instead of using rt. There was another or gate with all the commands that needed writeEnable0. Another or gate had div and mul to activate writeEnable1. I had a pin for li so that I could know that I was writing an immediate to the register. This was connected to a mux to teh writeportA later. I had sw connected to memWrite and lw connected to memLoad. These were just signals that would be connected to the RAM to control when it was activated and what it would be doing. I also had a output pin for halt and put. Since addi was the only command that needed a signed immediate I connected it to a mux that would pick between zero extend and sign extend. That way, the only time we would get a signed immediate would be when addi was being used. I also sent all the branch commands to a priority encoder for a branchOp code that would be used later. I sent all the branches to an or to know if we were branching. I then sent j, jr, and jal, to seperate output pins just so we knew when these three were being used or not. 

Based on all the outputs from the control most of the work was over. For the register file I just connected all the registers, connected rs to SelectWA since we were only ever writing to rs. The write enables were connected. For the read ports I just directly connected rs and rt. for the WriteDataA there were three muxes. The first mux was testing whether we were running a li. If yes then we sent in the immediate. If not, then we sent in the WriteDataA. The second mux was if we were loading from memory. If yes, then we sent in the output from the ram. THe third mux was whether we were running a jal. If yes, then we sent in the pc + 1 exntended. If all of these tests failed then we were just sending in WriteDataA which was the result from the ALU. 

ALUA was connected to the A port on the ALU which was always just the reading of rs. Connected to B was a mux that used the immediate Use output from the control that was mentioned earlier. This would decide whether the read of rt was sent in or the immediate. This immediate was already signed or unsigned based on whether we were running addi or not. The result was sent into WriteDataA which was already talked about, but result2 was sent into WriteDatab. This tunnel was connected to the WriteDtatb port on the register file. Then based on whether write enable1 was on from the control we would write or not. The only time writeEnable  1 was on was when we were running either div or mul. The GT, Z, and LT were connected to tunnels. We'll talk about those later. 

For the put, we just connected ALUa, which was the read tunnel of rs to a register and the output was connected to a splitter that split them accordingly to each display. 

For the RAM, ALUb was connected to the A and ALUa was connected to the D. I think this is because the address was always in rt and the data was in rs so they were connected accordingly. For the sel which is the activation of the RAM, I just put an or gate with memwrite and memload connected. The other ports were connected to the corresponding thing.

The final thing to do was handle branches and jumps. Most of the work for this was also already done in the control and at the writeportA of the register file. I had 4 mux setup together. And each selection port on the muxes were connceted to an and gate that saw whether we were branching and if either GT, Z, or LT were actaivted. These four were then connected to a mux with four pins. Through the logic either the branch was passed and the oc took the immediate value or the branch failed and pc took the plus one value of itself. coming our of that four pin mux were two other pins. The first tested whether we were jr jumping. In that case I just connceted the ALUa reading the rs to a splitter and put that into PC. The next mux tested whether we were j or jal jumping. In both those cases we just put the immediate into the pc, but jal was already handled by the connection to the writeA port on the register file. 

I think everything works. 